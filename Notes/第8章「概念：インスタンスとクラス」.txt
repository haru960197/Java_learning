第8章「概念：インスタンスとクラス」

オブジェクト指向でやることは
１．各オブジェクトの責務を考え、「属性」「操作」を定義する
２．各オブジェクトを仮想世界に生み出し、動かす。

オブジェクトを定義することはできず、クラスを定義することになる。よって、より具体的には
１．クラスを定義する
２．そのクラスに基づいてオブジェクト（インスタンス）を生み出す

現実世界の人や物に似せてクラスを作り、仮想世界を現実世界に似せていく！

Q.なぜオブジェクトを直接定義しないのか？
A.オブジェクトごとに定義していたら大変だから。クラスはオブジェクトを生成する金型のようなもの。よって、クラスを定義すれば、いくらでもオブジェクトを楽に大量生産できる。

「クラスから生成され、仮想世界で実際に活動する実体」を、オブジェクトではなく
インスタンス
と呼ぶ。
また、クラスからインスタンスを生成することを
インスタンス化
と呼ぶ。

・神様のクラスと登場人物のクラスが必要
インスタンスに指示を与える、神様のようなクラスが一つ独立して存在しなければ世界は動かない。それはMain.javaなど適当に独立して一つつくり、その中にmainメソッドを記述する。


・登場人物のクラスの大まかな書き方
基本的には普通の書き方だが、多少ルールがあるのと、変数に呼称がある。

public class クラス名 {
　　// 属性の定義
　　String name;
　　int hp;
　　int mp = 5; // 初期化も可能

　　// 操作の定義
　　public void sleep() {
　　　　this.hp = 100;
　　　　System.out.println(this.name + "は眠って、hpが100に回復した！");
　　}
　　public void sit(int sec) {
　　　　// 引数を受け取ることも可能
　　　　this.hp += sec;
　　　　System.out.println("～～～");
　　}
}

このように、属性→操作　の順に書いていく

属性は　変数
操作は　メソッド
として書いていく。この、属性を表す変数のことを「フィールド」と呼ぶ。
そして、フィールドとメソッドを合わせて、「メンバ」と呼ぶ
メソッドには、返り値の型の前に「static」はつけない！

・フィールドの参照
メソッド内部などで、自分のクラス内のフィールドを参照する場合は
this.フィールド名
と記述する。「this.」を付けないと、同じ名前のローカル変数や引数が先に参照される。

・定数フィールド
値を書き換えることのできない定数フィールドの宣言も可能
final 型 定数フィールド名(すべて大文字) = 値;
ex)
final int LEVEL = 10;
書き換えようとするとエラーが発生するようになる。
変数名はすべて大文字なことに注意！


・インスタンス化の方法
クラス名 変数名 = new クラス名();

クラスを定義すると、インスタンスを入れる変数の型が利用可能になる。
クラスはやはり金型なのである。
ex) Heroクラスのインスタンスを生成
Hero h1 = new Hero();
Hero h2 = new Hero();
実際にインスタンスを生成しているのは右辺の「new Hero()」であり、「=」によって、生成したインスタンスをHero型変数h1, h2に代入している。よって以下のように二行でも書ける。
Hero h1; // 変数を宣言
h1 = new Hero(); // インスタンスを代入

・インスタンスのフィールドとメソッドの利用
代入するとき
　変数名.フィールド名 = 値;
参照
　変数名.フィールド名;
メソッドの呼び出し
　変数名.メソッド名;
ex)
Hero h = new Hero();
h.name = "Haruki"; // 代入
h.hp = 10;
System.out.println(h.name + "のhpは" + h.hp + "だ！”); // 参照
h.sleep; // メソッドの呼び出し
System.out.println(h.name + "のhpは" + h.hp + "だ！”);

実行結果
Harukiのhpは10だ！
Harukiは眠ってhpが100に回復した！
Harukiのhpは100だ！

