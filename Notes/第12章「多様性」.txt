第12章「多様性」

多様性のあいまいなイメージ
・・・「あるものをあえてざっくり捉えることで、さまざまなメリットを享受しようという機能」

具体的には、is-aの関係にあるクラスは、継承元の親クラスの型として扱えるという機能。
親クラス 変数名 = new 子クラス();
このように、親クラスの型に子クラスのインスタンスを代入することができる。
子クラスのインスタンスはnewでメモリ上に確保されているが、コンパイラにはあくまで親クラスの型の変数として扱われるので、メンバは、親クラスに含まれているものにしかアクセスできない。

参照型の変数は、先頭アドレスを保持しているとともに、メンバにアクセスしようとしたときに、その先頭アドレスから何バイト先を参照すべきか、などを管理している。したがって、実際にメモリ上に子クラスのメンバが存在していたとしても、親クラスの型の変数に「そこを参照しろ」と命令しても、コンパイラは何バイト先にいけばいいのかなどがわからないのである。

したがって、変数の型とその中身のインスタンスの型が以下のように決定している。
①変数の型　：どのメソッドを「呼べるか」を決定する
②中身の型　：メソッドが呼ばれた時「どう動くか」を決定する

・ダウンキャスト
新たな型 変数2 = (新たな型)変数1
インスタンスは実際にメモリ上に存在するわけだから、変数の型だけ変えたい場合、ダウンキャストと呼ばれる、コンパイラに強制的に中身をほかの型に代入させる命令が必要である。

通常、ざっくりとらえた状態の変数を新たな型に代入するのはリスクが伴う。なぜならば、親クラスの型として宣言された変数には、多くの種類のクラスのインスタンスが代入できるからである。例えば、
Character c = new Hero();
として宣言した変数「c」を、Hero型の変数に代入したくなり、以下のように命令するとする
Hero h = c;
これはエラーになる。なぜなら、コンパイラとしては、「cが本当はHeroクラスのインスタンス」などということは知らず、あくまで「cはCharacterクラスだ」としか知らないからである。
これを強制するには、ダウンキャストが必要、というわけだ。
Hero h = (Hero)c;

ただし、誤ってダウンキャストしてしまい、コンパイルは通っても、実行時にエラーが起きる場合もある。これを防ぐために、安全にキャストできるかを判定する方法がある。
変数 instanceof 型名
ex)
if(c instanceof Hero) {
	Hero h = (Hero)c;
	h.attack();
}

・多様性のメリット
①複数の型を同一視して配列を利用する
例えば、Hero, Wizard, Thief,...などの様々なキャラクターのパーティーを、一つの配列として扱うことができる。
ex)
Character[] party = new Character[3];
party[0] = new Hero();
party[1] = new Wizard();
party[2] = new Thief();
for (Charcter c : party) c.hp += 50; // 全キャラクターの一度にhpを回復

②複数の型を同一視して引数として受け取る
メソッドの引数の型をおおまかに指定することで、さまざまな型に対して同じ処理を行える。
ex)
public void heel(Character c) {
	System.out.println(c.name + "のhpを50回復した！");
	c += 50;
}
public static void main(String[] args) {
	Hero h = new Hero();
	Wizard w = new Wizard();
	heel(h);
	heel(q);
}

・多様性の本質
呼び出し側が相手を同一視して同じように呼び出したとしても、呼び出される側は、きちんと自分に決められた動作をする。このように、同じ呼び方で様々な動きをみせることから、「多様性」と名付けられた。